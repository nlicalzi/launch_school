What is the Two-Layer Problem?
    - Learning to solve problems while simultaneously memorizing the syntax of a particular language.
    - We need instead to simplify so we're not fighting a multi-front battle.

How can we get around the Two-Layer Problem?
    - By using PEDAC

What does PEDAC stand for?
    - Two objectives: Processing the problem (PEDA) and Coding with intent (C)
    - P: Understanding the Problem
        - Identify expected input and output
        - Make the requirements explicit
        - Identify rules
        - Mental model of the problem
    - E: Examples/Test Case (Validate understanding of the problem)
    - D: Data Structure (How we represent data when converting input to output)
    - A: Algorithm (Steps for converting input to output)
    - C: Code (Implementation of Algorithm)

Why use PEDAC?
    - Avoiding "hack and slash" coding
        - Often leads to missed requirements, unforeseen edge cases, hard to
          understand code, and code that's difficult to maintain.

###Lesson 2 Vocab (for flash cards)
Operator Precedence
  - What is Operator Precedence?
    - The set of rules Ruby follows to determine evaluation order of operations in an expression.
  - Reference: https://www.techotopia.com/index.php/Ruby_Operator_Precedence

Short Circuit Evaluation
  - What is short-circuit evaluation?
    -The semantics of boolean operators in a given programming language in which the second argument
    is evaluated only if the first argument does not suffice to determine the value of the expression.
    In effect, short-circuit operators can be called 'control structures', since they guide evaluation.

  - && and || will stop evaluating once they can guarantee return value
    - && short circuits with False as the left-hand value
      - ex. cook_dinner() or raise(RuntimeError, "Not in the mood.")
      
    - || short circuits with True as the "left-hand" value (like a reversed 'unless')
      - ex. raise(RuntimeError, "Not in the mood.") unless cook_dinner()

  - &&, aka Logical 'AND' has higher precedence than ||, aka Logical 'OR' (b/c of short circuiting)
  - ||, aka Logical 'OR' has lower precedence than &&, aka Logical 'AND' (b/c of short circuiting)


Implicit iteration (more idiomatic for Ruby than explicit [each vs. for loop])
  - How does iteration work in Ruby?
    Iterations in Ruby are done by passing callback closures (read: blocks) to container methods.
    
  - What iteration methods are commonly used in Ruby?
    Loops: 
      loop (unconditional, uses break to exit)
      while
      until
      for
    Iterators:
      #each
      #collect
      #times
      #upto // downto
      #step
      #each_index
      #each_with_index
    Complex:
      #map
      #select
      #reject
      #partition
      #reduce
      #all?
      #any?
  
  - What is implicit iteration? Provide an example.
    - A way of iterating through the elements of a container object without using an explicit iterator object.
    Sometimes calld 'internal iteration' because the code fully executes within the context of the iterable
    object, and programmer only provides the operation to execute (using an anonymous function [lambda in Python]).
    
    iterable.each do |value|
      puts value
    end
    
    // OR //
    
    iterable.each { |value| puts value }
    
  - What is explicit iteration? Provide an example.
    - Explicit, or 'external', iteration uses 'element access' and 'element traversal' to iterate over an object.
      - Element access: referencing one particular element in the object collection.
      - Element traversal: modifying itself so it points to the next element.
    - Ex. Generators in Python; using a "loop counter"
    
  - Do we prefer implicit or explicit iteration as Rubyists? Why?
    - Implicit iteration is preferred in Ruby, relying heavily on the Enumerable module on Arrays and Hashes.
      It generally results in improved code clarity and consistency.
  
  - https://en.wikipedia.org/wiki/Iterator#Implicit_iterators

Assignment
  - Self assignment
      = : equal operator
      += : add AND; x += y equiv. x = x + y
      -= : subtract AND; x -= y equiv. x = x - y
      *= : multiply AND; x *= y equiv. x = x * y
      /= : divide AND; x /= y equiv. x = x / y
      %= : modulus AND; x %= y equiv. x = x % y
      **= : exponent AND; x **= y equiv. x = x**y
      
  - Multiple assignments
      var1, var2, var3 = 10, 20, 30
      
      myArray = %w(John Michel Fran Doug)
      var1, var2, var3, var4 = *myArray
        var1 => John, var2 => Michel, var3 => Fran, var4 => Doug
      
      names, school = myArray, 'St. Whatever'.
        names => ['John', 'Michel', 'Fran', 'Doug]
        school => 'St. Whatever'
      
  - Conditional assignment 
      x ||= "default"
        value of x will be replaced with "default", but only if x is nil or false
      x &&= x.next_node
        x will be set to x.next_node, but only if x is NOT nil or false

  - https://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Operators#Assignment

What is the difference between Declarative and Imperative syntax?
  - "With imperative code, you're telling your program *how* to do something, and with declarative
  code, you're telling your program *what* you want to do." - Tyler Mcginnis, React Fundamentals
  
  - Imperative code focuses on the steps of implementation, or the how.
  - Declarative code uses a Ruby block to make a declaration/expression of the problem itself, or the what.
  - For more, read up on Higher Order Functions in Ruby. 
  
  - Reading: http://queirozf.com/entries/functional-programming-with-ruby-procs-lambdas-closures-and-functions
  
Stack Trace
Multiple Assignment
Trapping the error
Code smell
`rescue`
PRY - REPL for debugging
yaml, psych
do/while vs. while loops
Does a while loop with do/end count as a block?
truthiness
types of variables in ruby: https://launchschool.com/books/ruby/read/variables#typesofvariables
method definition
method invocation
method invocation with a block
    block acts as an argument to the method
variable scoping within a block: inner scopes/nested scopes
    outer scope variables can be accessed by inner scope
    inner scope variables cannot be accessed in outer scope
    peer (same-level) scopes do not conflict
    nested blocks
variable shadowing
    - reuse of a variable name in an inner scope blocks access to outer scoped
      variable
    - TO BE AVOIDED! easily done with long/descriptive variable names
      ex. n = 10
        [1, 2, 3].each do { |n| puts n } => "1" "2" "3"
lexical scope (constants vs. local variables)
Object Passing Strategies (Strict Evaluation)
  - pass by reference (references original object)
  - pass by value (copies of original object)
pass by reference of the value // call by sharing:
  when an operation within the method mutates the caller, it will affect the
  original object
reassignment
  - Assignment always binds the target variable on the left hand side of the =
    to the object referenced by the right hand side. The object originally
    referenced by the target variable is never modified.
  - Assignment operators are also non-mutating: *=, +=, -=, %=
mutability
non-mutating methods
  A method is said to be non-mutating with respect to an argument or its calling
  object if it does not modify it.
mutating methods
indexed assignment (is it mutating? no.)
concatenation (is it mutating? yes)
re/assignment (is it mutating?)
setters (are they mutating? yes)
setters
object passing (passing the object to the method)
caller (sometimes called the receiver/the object on which the method is called)
evaluation strategy
  How a language determines when expressions are evaluated and what a method can do with resulting objects.
strict evaluation
  Every expression is evaluated and converted to an object before it is passed along to a method. (RUBY USES THIS STRICTLY)
what is an evaluation strategy?
what evaluation strategy does ruby use? how does it work?
literal reference / anonymous (unnamed) reference
double bang (!!) -- first returns the opposite boolean value, second inverts (used to convert object to boolean)
String#count
String#delete
