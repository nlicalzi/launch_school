What is the Two-Layer Problem?
    - Learning to solve problems while simultaneously memorizing the syntax of a particular language.
    - We need instead to simplify so we're not fighting a multi-front battle.

How can we get around the Two-Layer Problem?
    - By using PEDAC

What does PEDAC stand for?
    - Two objectives: Processing the problem (PEDA) and Coding with intent (C)
    - P: Understanding the Problem
        - Identify expected input and output
        - Make the requirements explicit
        - Identify rules
        - Mental model of the problem
    - E: Examples/Test Case (Validate understanding of the problem)
    - D: Data Structure (How we represent data when converting input to output)
    - A: Algorithm (Steps for converting input to output)
    - C: Code (Implementation of Algorithm)

Why use PEDAC?
    - Avoiding "hack and slash" coding
        - Often leads to missed requirements, unforeseen edge cases, hard to
          understand code, and code that's difficult to maintain.

###Lesson 2 Vocab (for flash cards)
Operator Precedence
  - What is Operator Precedence?
    - The set of rules Ruby follows to determine evaluation order of operations in an expression.
  - Reference: https://www.techotopia.com/index.php/Ruby_Operator_Precedence

Short Circuit Evaluation
  - What is short-circuit evaluation?
    -The semantics of boolean operators in a given programming language in which the second argument
    is evaluated only if the first argument does not suffice to determine the value of the expression.
    In effect, short-circuit operators can be called 'control structures', since they guide evaluation.

  - && and || will stop evaluating once they can guarantee return value
    - && short circuits with False as the left-hand value
      - ex. cook_dinner() or raise(RuntimeError, "Not in the mood.")
    - || short circuits with True as the "left-hand" value (like a reversed 'unless')
      - ex. raise(RuntimeError, "Not in the mood.") unless cook_dinner()

  - &&, aka Logical 'AND' has higher precedence than ||, aka Logical 'OR' (b/c of short circuiting)
  - ||, aka Logical 'OR' has lower precedence than &&, aka Logical 'AND' (b/c of short circuiting)


Implicit iteration (more idiomatic for Ruby than explicit [each vs. for loop])
  - What is implicit iteration? Provide an example.
    - A way of iterating through the elements of a container object without using an explicit iterator object.
  - What is explicit iteration? Provide an example.
    - Generators in Python; using a "loop counter"
  - Do we prefer implicit or explicit iteration as Rubyists? Why?
  - https://en.wikipedia.org/wiki/Iterator#Implicit_iterators

x ||= y (assignment operator) -> if x is nil or false, set x to y
declarative vs. imperative syntax
Stack Trace
Multiple Assignment
Trapping the error
Code smell
`rescue`
PRY - REPL for debugging
yaml, psych
do/while vs. while loops
Does a while loop with do/end count as a block?
truthiness
types of variables in ruby: https://launchschool.com/books/ruby/read/variables#typesofvariables
method definition
method invocation
method invocation with a block
    block acts as an argument to the method
variable scoping within a block: inner scopes/nested scopes
    outer scope variables can be accessed by inner scope
    inner scope variables cannot be accessed in outer scope
    peer (same-level) scopes do not conflict
    nested blocks
variable shadowing
    - reuse of a variable name in an inner scope blocks access to outer scoped
      variable
    - TO BE AVOIDED! easily done with long/descriptive variable names
      ex. n = 10
        [1, 2, 3].each do { |n| puts n } => "1" "2" "3"
lexical scope (constants vs. local variables)
Object Passing Strategies (Strict Evaluation)
  - pass by reference (references original object)
  - pass by value (copies of original object)
pass by reference of the value // call by sharing:
  when an operation within the method mutates the caller, it will affect the
  original object
reassignment
  - Assignment always binds the target variable on the left hand side of the =
    to the object referenced by the right hand side. The object originally
    referenced by the target variable is never modified.
  - Assignment operators are also non-mutating: *=, +=, -=, %=
mutability
non-mutating methods
  A method is said to be non-mutating with respect to an argument or its calling
  object if it does not modify it.
mutating methods
indexed assignment (is it mutating? no.)
concatenation (is it mutating? yes)
re/assignment (is it mutating?)
setters (are they mutating? yes)
setters
object passing (passing the object to the method)
caller (sometimes called the receiver/the object on which the method is called)
evaluation strategy
  How a language determines when expressions are evaluated and what a method can do with resulting objects.
strict evaluation
  Every expression is evaluated and converted to an object before it is passed along to a method. (RUBY USES THIS STRICTLY)
what is an evaluation strategy?
what evaluation strategy does ruby use? how does it work?
literal reference / anonymous (unnamed) reference
double bang (!!) -- first returns the opposite boolean value, second inverts (used to convert object to boolean)
String#count
String#delete
