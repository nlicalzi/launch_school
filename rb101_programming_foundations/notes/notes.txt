What is the Two-Layer Problem?
    - Learning to solve problems while simultaneously memorizing the syntax of a particular language.
    - We need instead to simplify so we're not fighting a multi-front battle.

How can we get around the Two-Layer Problem?
    - By using PEDAC

What does PEDAC stand for?
    - Two objectives: Processing the problem (PEDA) and Coding with intent (C)
    - P: Understanding the Problem
        - Identify expected input and output
        - Make the requirements explicit
        - Identify rules
        - Mental model of the problem
    - E: Examples/Test Case (Validate understanding of the problem)
    - D: Data Structure (How we represent data when converting input to output)
    - A: Algorithm (Steps for converting input to output)
    - C: Code (Implementation of Algorithm)

Why use PEDAC?
    - Avoiding "hack and slash" coding
        - Often leads to missed requirements, unforeseen edge cases, hard to
          understand code, and code that's difficult to maintain.

***Lesson 2 Vocab (for flash cards)***
Operator Precedence
&& (has higher precedence than || [because of short circuiting])
|| (has lower precedence than && [because of short circuiting])
Short Circuiting-- && and || will stop evaluating once they can guarantee return value
Implicit iteration (more idiomatic for Ruby than explicit [each vs. for loop])
x ||= y (assignment operator) -> if x is nil or false, set x to y
declarative vs. imperative syntax
Stack Trace
Multiple Assignment
Trapping the error
Code smell
`rescue`
PRY - REPL for debugging
yaml, psych
do/while vs. while loops
Does a while loop with do/end count as a block?
truthiness
types of variables in ruby: https://launchschool.com/books/ruby/read/variables#typesofvariables
method definition
method invocation
method invocation with a block
    block acts as an argument to the method
variable scoping within a block: inner scopes/nested scopes
    outer scope variables can be accessed by inner scope
    inner scope variables cannot be accessed in outer scope
    peer (same-level) scopes do not conflict
    nested blocks
variable shadowing
    - reuse of a variable name in an inner scope blocks access to outer scoped
      variable
    - TO BE AVOIDED! easily done with long/descriptive variable names
      ex. n = 10
        [1, 2, 3].each do { |n| puts n } => "1" "2" "3"
lexical scope (constants vs. local variables)
Object Passing Strategies (Strict Evaluation)
  - pass by reference (references original object)
  - pass by value (copies of original object)
pass by reference of the value // call by sharing:
  when an operation within the method mutates the caller, it will affect the
  original object
reassignment
  - Assignment always binds the target variable on the left hand side of the =
    to the object referenced by the right hand side. The object originally
    referenced by the target variable is never modified.
  - Assignment operators are also non-mutating: *=, +=, -=, %=
mutability
non-mutating methods
  A method is said to be non-mutating with respect to an argument or its calling
  object if it does not modify it.
mutating methods
indexed assignment (is it mutating? no.)
concatenation (is it mutating? yes)
re/assignment (is it mutating?)
setters (are they mutating? yes)
setters
object passing (passing the object to the method)
caller (sometimes called the receiver/the object on which the method is called)
evaluation strategy
  How a language determines when expressions are valuated and what a method can do with resulting objects.
strict evaluation
  Every expression is evaluated and converted to an object before it is passed along to a method. (RUBY USES THIS STRICTLY)
what is an evaluation strategy?
what evaluation strategy does ruby use? how does it work?
literal reference / anonymous (unnamed) reference
double bang (!!) -- first returns the opposite boolean value, second inverts (used to convert object to boolean)
String#count
String#delete
