What is the Two-Layer Problem?
    - Learning to solve problems while simultaneously memorizing the syntax of a particular language.
    - We need instead to simplify so we're not fighting a multi-front battle.

How can we get around the Two-Layer Problem?
    - By using PEDAC

What does PEDAC stand for?
    - Two objectives: Processing the problem (PEDA) and Coding with intent (C)
    - P: Understanding the Problem
        - Identify expected input and output
        - Make the requirements explicit
        - Identify rules
        - Mental model of the problem
    - E: Examples/Test Case (Validate understanding of the problem)
    - D: Data Structure (How we represent data when converting input to output)
    - A: Algorithm (Steps for converting input to output)
    - C: Code (Implementation of Algorithm)

Why use PEDAC?
    - Avoiding "hack and slash" coding
        - Often leads to missed requirements, unforeseen edge cases, hard to
          understand code, and code that's difficult to maintain.

***Lesson 2 Vocab (for flash cards)***
Operator Precedence
&&
||
Short Circuiting-- && and || will stop evaluating once they can guarantee return value
Implicit iteration (more idiomatic for Ruby than explicit [each vs. for loop])
x ||= y (assignment operator) -> if x is nil or false, set x to y
declarative vs. imperative syntax
Stack Trace
Multiple Assignment
Trapping the error
Code smell
`rescue`
PRY - REPL for debugging
yaml, psych
do/while vs. while loops
truthiness
types of variables in ruby: https://launchschool.com/books/ruby/read/variables#typesofvariables
method definition
method invocation
method invocation with a block
    block acts as an argument to the method
variable scoping within a block: inner scopes/nested scopes
    outer scope variables can be accessed by inner scope
    inner scope variables cannot be accessed in outer scope
    peer (same-level) scopes do not conflict
    nested blocks
variable shadowing
    reuse of a variable name in an inner scope blocks access to outer scoped variable
    TO BE AVOIDED! easily done with long/descriptive variable names
    ex. n = 10
        [1, 2, 3].each do { |n| puts n } => "1" "2" "3"
lexical scope (constants vs. local variables)

